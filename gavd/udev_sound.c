/* Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */
#include <assert.h>
#include <libudev.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define __USE_UNIX98            /* For pthread_mutexattr_settype et al. */
#include <pthread.h>

#include "utils.h"
#include "thread_management.h"
#include "initialization.h"
#include "verbose.h"
#include "udev_sound.h"
#include "device_info.h"

static unsigned is_action(const char *desired,
                          const char *actual) __attribute__((nonnull(1)));

/* Matches Alsa sound device entries generated by udev.  For
 * example:
 *
 *   /devices/pci0000:00/0000:00:1b.0/sound/card1/pcmC1D0p
 *
 * We want to be able to extract:
 *
 *   o The card number
 *   o The device number
 *   o If it's 'playback' (p) or 'capture' (c).  (It may not be both)
 *
 * Given the example above, the following matches should occur:
 *
 *
 *   |                        A                           |
 *                                                   BBCCCD
 *   /devices/pci0000:00/0000:00:1b.0/sound/card1/pcmC1D10p
 *
 * A: The whole regex will be matched.
 * B: The card.
 * C: The device.
 * D: 'p' (playback) or 'c' (capture)
 *
 * The order of the offsets in the 'pmatch' buffer does not appear
 * to match with the documentation:
 *
 *     Each rm_so element that is not -1 indicates the start
 *     offset of the next largest substring match within the
 *     string.
 *
 * But are, instead, filled in the same order presented in the
 * string.  To alleviate possible issudes, the 'C' (card) and 'D'
 * (device) identifying characters are included in the result.
 */
static const char pcm_regex_string[] = "^.*pcm(C[0-9]+)(D[0-9]+)([pc])";
static regex_t pcm_regex;

static char const * const  subsystem = "sound";
static struct udev        *udev;

static unsigned is_action(const char *desired, const char *actual)
{
    return actual != NULL && strcmp(desired, actual) == 0;
}

static unsigned is_action_add(const char *action)
{
    return is_action("add", action);
}

static unsigned is_action_remove(const char *action)
{
    return is_action("remove", action);
}

static unsigned is_internal_bus(const char *bus)
{
    return (bus != NULL &&
            (strcmp(bus, "pci") == 0 ||
             strcmp(bus, "platform") == 0));
}

static unsigned is_external_bus(const char *bus)
{
    return (bus != NULL &&
            (strcmp(bus, "usb") == 0));
}

static unsigned is_internal_device(struct udev_device *dev)
{
    struct udev_device *parent = udev_device_get_parent(dev);
    while (parent != NULL) {
        const char *name = udev_device_get_subsystem(parent);

        if (name != NULL) {
            if (is_external_bus(name)) {
                return 0;
            } else if (is_internal_bus(name)) {
                return 1;
            }
        }
        parent = udev_device_get_parent(parent);
    }
    return 0;
}

/* get_usb_device_speed: Determine if a usb device is fast or slow.
 *
 *   Return: 0: device speed could not be determined.
 *   Return: 1: device speed determined
 *
 *   When the speed cannot be determined, '*speed' is not updated.
 *   When the speed can be determined, '*speed' is updated.
 */
static unsigned get_usb_device_speed(struct udev_device *dev,
                                     device_speed_t     *speed)
{
    unsigned            result = 0;
    struct udev_device *parent;

    parent = udev_device_get_parent_with_subsystem_devtype(dev,
                                                           "usb", "usb_device");
    /* If the speed cannot be determined to be either '12' or '480',
     * then we consider that we don't know the speed of the specific
     * device.
     */
    if (parent != NULL) {
        const char *attr  = udev_device_get_sysattr_value(parent, "speed");

        if (attr != NULL) {
            if (strcmp(attr, "12") == 0) {
                *speed = DS_SLOW;
                result = 1;
            } else if (strcmp(attr, "480") == 0) {
                *speed = DS_FAST;
                result = 1;
            }
        }
    }
    return result;
}


/* is_alsa_device: Determine if a device is an alsa device.
 */
static unsigned is_alsa_device(struct udev_device  *dev,
                               unsigned            *internal,
                               unsigned            *card_number,
                               unsigned            *device_number,
                               device_speed_t      *speed,
                               direction_t         *direction,
                               const char         **sysname)
{
    regmatch_t  m[4];
    const char *devpath = udev_device_get_devpath(dev);

    /* Upon successful regex match:
     *
     *  m[0]: full match
     *  m[1]: card number
     *  m[2]: device number
     *  m[3]: playback / capture
     *
     *  Refer to 'pcm_regex_string'.
     */

    if (devpath != NULL &&
        regexec(&pcm_regex, devpath, sizeof(m) / sizeof(m[0]), m, 0) == 0) {

        *internal      = is_internal_device(dev);
        *card_number   = (unsigned)atoi(&devpath[m[1].rm_so + 1]);
        *device_number = (unsigned)atoi(&devpath[m[2].rm_so + 1]);
        *sysname       = udev_device_get_sysname(dev);
        *direction     = devpath[m[3].rm_so] == 'p' ? D_PLAYBACK
                                                    : D_CAPTURE;

        if (!get_usb_device_speed(dev, speed)) {
            *speed = DS_FAST;
        }
        return 1;
    }
    return 0;
}

static void add_udev_device_if_alsa_device(struct udev_device *dev)
{
    /* If the device, 'dev' is an alsa device, add it to the set of
     * devices available for I/O.  Mark it as the active device.
     */
    unsigned        internal;
    unsigned        card_number;
    unsigned        device_number;
    direction_t     direction;
    device_speed_t  speed;
    const char     *sysname;

    if (is_alsa_device(dev, &internal, &card_number,
                       &device_number, &speed, &direction, &sysname)) {
        device_add_alsa(sysname, internal, card_number,
                        device_number, speed, direction);
    }
}

static void remove_device_if_card(struct udev_device *dev)
{
    unsigned        internal;
    unsigned        card_number;
    unsigned        device_number;
    direction_t     direction;
    device_speed_t  speed;
    const char     *sysname;

    if (is_alsa_device(dev, &internal, &card_number,
                       &device_number, &speed, &direction, &sysname)) {
        device_remove_alsa(sysname, card_number, device_number);
    }
}

static void enumerate_devices(void)
{
    struct udev_enumerate  *enumerate = udev_enumerate_new(udev);
    struct udev_list_entry *dl;
    struct udev_list_entry *dev_list_entry;

    udev_enumerate_add_match_subsystem(enumerate, subsystem);
    udev_enumerate_scan_devices(enumerate);
    dl = udev_enumerate_get_list_entry(enumerate);

    udev_list_entry_foreach(dev_list_entry, dl) {
        const char         *path = udev_list_entry_get_name(dev_list_entry);
        struct udev_device *dev  = udev_device_new_from_syspath(udev, path);

        add_udev_device_if_alsa_device(dev);
    }
    udev_enumerate_unref(enumerate);

    device_set_primary_playback_and_capture();
}

static void udev_sound_subsystem_monitor_work(void)
{
    struct udev_monitor *mon = udev_monitor_new_from_netlink(udev, "udev");
    int fd;

    udev_monitor_filter_add_match_subsystem_devtype(mon, subsystem, NULL);
    udev_monitor_enable_receiving(mon);
    fd = udev_monitor_get_fd(mon);
    enumerate_devices();

    while (!thread_management.tm_exit) {
        fd_set              fds;
        struct timeval      timeout;
        int                 ret;
        struct udev_device *dev;

        FD_ZERO(&fds);
        FD_SET(fd, &fds);
        timeout.tv_sec  = 0;
        timeout.tv_usec = 0;
        ret             = select(fd + 1, &fds, NULL, NULL, &timeout);

        if (ret > 0 && FD_ISSET(fd, &fds)) {
            dev = udev_monitor_receive_device(mon);
            if (dev) {
                const char *action = udev_device_get_action(dev);

                if (is_action_add(action)) {
                    add_udev_device_if_alsa_device(dev);
                } else if (is_action_remove(action)) {
                    remove_device_if_card(dev);
                }
                udev_device_unref(dev);
            } else {
                verbose_log(0, LOG_ERR,
                            "%s (internal error): No device obtained",
                            __FUNCTION__);
            }
        }
        usleep(250000);         /* 0.25 second */
    }
}

static void *udev_sound_subsystem_monitor(void *arg)
{
    thread_descriptor_t *desc = (thread_descriptor_t *)arg;
    desc = desc;

    /* Initialization Code. */
    pthread_barrier_wait(&thread_management.tm_create_barrier);

    /* Wait for all other threads to start. */
    pthread_barrier_wait(&thread_management.tm_start_barrier);
    udev_sound_subsystem_monitor_work();
    return NULL;
}

static void initialize(void)
{
    udev = udev_new();
    assert(udev != NULL);

    compile_regex(&pcm_regex, pcm_regex_string);
}


static void finalize(void)
{
    udev_unref(udev);
    regfree(&pcm_regex);
}

INITIALIZER("udev listener", initialize, finalize);
THREAD_DESCRIPTOR("udev listener: input subsystem", TSP_NORMAL,
                  udev_sound_subsystem_monitor);
